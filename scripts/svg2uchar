#!/usr/bin/env bash

# svg2uchar - Convert SVG to a single Braille Unicode character representing the SVG
# Algorithm:
#   1. Resize the SVG to 4×8 pixels (width×height).
#   2. For each of the 32 pixels, set bit = 1 if grayscale < 128 else 0.
#   3. Fold the 32-bit array into 8 bits by OR-ing every group of 4 rows:
#        final[i] = row0[i] | row1[i] | row2[i] | row3[i]
#   4. Map those 8 bits to Braille dots (⣿ range U+2800 – U+28FF).
#   5. Output the single Braille character.
# This gives up to 256 unique glyphs while remaining one code-point wide.
# Produces up to 256 unique glyphs (U+2800–U+28FF) using an 2×4 pixel sample.
# Usage: svg2uchar input.svg
# Usage: svg2uchar input.svg

# Check if input file is provided
if [ $# -eq 0 ]; then
    echo "Usage: $0 input.svg"
    exit 1
fi

input_file="$1"
temp_png="${input_file%.*}.tmp.png"

# Check if ImageMagick is installed
if ! command -v convert &> /dev/null; then
    echo "Error: ImageMagick is required but not installed."
    echo "Please install it with: sudo apt-get install imagemagick"
    exit 1
fi

# Extract PBM ASCII (P1) pixels directly: 2 x 4 pixels → 8 bits
# Generate 4×8 grayscale text data via ImageMagick and extract 0/1 brightness bits
pixel_bits=$(magick convert -background none -resize 4x8\! -colorspace gray -depth 8 "$input_file" txt:- 2>/dev/null | \
  awk -F'[(),]' '/^[ ]*[0-9]+/ {val=strtonum($3); printf (val<128?1:0)}')

# Expect 32 bits (4×8). If not, fallback.
if [ ${#pixel_bits} -ne 32 ]; then
    echo "•"
    exit 0
fi

# Fold 32 bits (rows 0-7) into 8 final bits (columns 0-7)
final_bits=""
for ((col=0; col<8; col++)); do
    bit=0
    for ((row=0; row<4; row++)); do
        idx=$((row*8 + col))
        if [ "${pixel_bits:$idx:1}" = "1" ]; then bit=1; break; fi
    done
    final_bits+=$bit
done

# Map to Braille code-point
value=0
# final_bits index 0..7 odpowiada kropkom Braille'a w kolejności:
# 1,4,2,5,3,6,7,8 (kolumny od lewej do prawej, 4 wiersze ⇒ 8 bitów)
for i in {0..7}; do
    bit=${final_bits:$i:1}
    if [ "$bit" = "1" ]; then
        case $i in
            0) dot=1;; 1) dot=4;; 2) dot=2;; 3) dot=5;; 4) dot=3;; 5) dot=6;; 6) dot=7;; 7) dot=8;;
        esac
        value=$((value | 1 << (dot-1)))
    fi
done

codepoint=$((0x2800 + value))
# Wypisz gotowy znak Braille (UTF-8) i zakończ
printf "\\U%08x\n" "$codepoint"
exit 0

# Map PBM bits to Braille dot positions
# Dots: 1 4
#       2 5
#       3 6
#       7 8
value=0
for idx in {0..7}; do
    bit=${map:$idx:1}
    # Row = idx / 2, Col = idx % 2
    row=$((idx / 2))
    col=$((idx % 2))
    case $row,$col in
        0,0) dot=1;; 0,1) dot=4;;
        1,0) dot=2;; 1,1) dot=5;;
        2,0) dot=3;; 2,1) dot=6;;
        3,0) dot=7;; 3,1) dot=8;;
    esac
    if [ "$bit" = "1" ]; then
        value=$((value | 1 << (dot-1)))
    fi
done

codepoint=$((0x2800 + value))
printf "\U%08x\n" "$codepoint"



# Define Unicode block characters and their patterns
# Each character is represented by 4x2 blocks (8 bits total)
# Format: "char:binary_pattern"
blocks=(
    "█:11111111"   # Full block
    "▀:11110000"   # Upper half block
    "▄:00001111"   # Lower half block
    "▌:11110000"   # Left half block
    "▐:00001111"   # Right half block
    "▘:11000000"   # Top-left quadrant
    "▝:00110000"   # Top-right quadrant
    "▖:00001100"   # Bottom-left quadrant
    "▗:00000011"   # Bottom-right quadrant
    "▚:10011001"   # Diagonal cross
    "▞:01100110"    # Reverse diagonal cross
    "▙:11111100"    # Top-left and bottom-right blocks
    "▛:11110011"    # Top and left blocks
    "▜:11001111"    # Top and right blocks
    "▟:00111111"    # Bottom and right blocks
    "▙:11111100"    # Top and bottom blocks
    "▀:11110000"    # Top half block (same as upper half)
    "▄:00001111"    # Bottom half block (same as lower half)
    "▌:11110000"    # Left half block (same as left half)
    "▐:00001111"    # Right half block (same as right half)
    "■:11111111"    # Full block (alternative)
    "□:00000000"    # Empty block (for contrast)
    "•:00011000"    # Bullet (center dot)
    "·:00011000"    # Middle dot (same as bullet)
    "○:00111100"    # Circle
)

# If we couldn't get image data, return a default character
if [ -z "$data" ] || [ ${#data} -lt 8 ]; then
    echo "•"
    exit 0
fi

# Take first 8 bits (for 8x1 image) or first 8 rows (for 4x2 image)
data=${data:0:8}

# Find the best matching block character
best_char="•"  # Default to bullet point
best_score=0

for block in "${blocks[@]}"; do
    IFS=':' read -r char pattern <<< "$block"
    
    # Calculate similarity score
    score=0
    for ((i=0; i<8; i++)); do
        if [ "${data:$i:1}" = "${pattern:$i:1}" ]; then
            ((score++))
        fi
    done
    
    # Update best match if this is better
    if [ $score -gt $best_score ]; then
        best_score=$score
        best_char="$char"
    fi
done

# Output the best matching character
echo "$best_char"
